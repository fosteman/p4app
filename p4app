#!/usr/bin/env bash
# Ensure the LANG environment variable is set to UTF-8
export LANG=en_US.UTF-8
export LC_ALL=en_US.UTF-8

P4APP_IMAGE=${P4APP_IMAGE:-p4lang/p4app:latest}
P4APP_CONTAINER_ARGS=${P4APP_CONTAINER_ARGS:-""}

# Ensure QEMU is set up for cross-platform execution if on arm64
function setup_qemu() {
    if ! docker run --rm --privileged multiarch/qemu-user-static --reset -p yes &>/dev/null; then
        echo "Setting up QEMU for cross-platform Docker support."
        docker run --rm --privileged multiarch/qemu-user-static --reset -p yes
    fi
}

# Run QEMU setup if on arm64 platform
if [[ "$(uname -m)" == "aarch64" ]]; then
    setup_qemu
fi

# Function to get absolute path
myrealpath() {
    [[ $1 = /* ]] && echo "$1" || echo "$PWD/${1#./}"
}

P4APP_LOGDIR=$(myrealpath "${P4APP_LOGDIR:-/tmp/p4app_logs}")

# Function to check and fix UTF-8 encoding
function check_and_fix_utf8() {
    local file="$1"
    if ! file "$file" | grep -q "UTF-8"; then
        echo "Invalid UTF-8 detected in: $file"

        # Fix encoding by removing invalid characters and creating a fixed file
        local fixed_file="${file}.fixed"
        iconv -f ISO-8859-1 -t UTF-8//IGNORE "$file" -o "$fixed_file" 2>/dev/null

        if [ $? -eq 0 ]; then
            mv "$fixed_file" "$file"
            echo "Fixed encoding in: $file"
        else
            echo "Failed to fix encoding in: $file"
            rm -f "$fixed_file"
        fi
    else
        echo "Valid UTF-8: $file"
    fi
}

# Function to get absolute filename
function get_abs_filename() {
    echo "$(cd "$(dirname "$1")" && pwd)/$(basename "$1")"
}

# Normalize path by removing any trailing slash
function normalize_path() {
    echo ${1%/}
}

# Build command function
function build-command {
    local output_file=${2:-"out.json"}
    run-command "$1" --build-only "${@:3}"
    rc=$?

    [ $rc -eq 0 ] && cp "$P4APP_LOGDIR/program.json" "$output_file"
    exit $rc
}

# Run p4app function with Docker container
function run-p4app {
    APP_TO_RUN=/tmp/app.tar.gz
    P4APP_NAME=${P4APP_NAME:-"p4app_$RANDOM"}
    docker run --platform linux/amd64 --privileged --interactive --tty --rm \
        --name "$P4APP_NAME" \
        -v "$1:$APP_TO_RUN" \
        -v "$P4APP_LOGDIR:/tmp/p4app_logs" \
        $P4APP_CONTAINER_ARGS \
        $P4APP_IMAGE "$APP_TO_RUN" "${@:2}"
}

# Run command function to handle .p4app packages
# Updated run-command to create tar without extended headers (pax)
function run-command {
    if [ -d "$1" ]; then
        PACKAGE_DIR=$(normalize_path "$1")
        APP_FILE=$(mktemp /tmp/p4app.tar.gz.XXXXXX)

        # Check and fix UTF-8 encoding for each file in the directory
        for file in "$PACKAGE_DIR"/*; do
            check_and_fix_utf8 "$file"
        done

        # Package the files without pax headers (extended headers)
        tar --format=ustar -czf "$APP_FILE" -C "$PACKAGE_DIR" .
        run-p4app "$APP_FILE" "${@:2}"
        rc=$?
        rm "$APP_FILE"
    elif [ -f "$1" ]; then
        APP_FILE=$(get_abs_filename "$1")

        # Check and fix UTF-8 encoding for the file
        check_and_fix_utf8 "$APP_FILE"

        run-p4app "$APP_FILE" "${@:2}"
        rc=$?
    else
        echo "Couldn't read p4app package: $1"
        exit 1
    fi
    return $rc
}
# Pack command function to compress a directory
function pack-command {
    if [ -d "$1" ]; then
        PACKAGE_DIR=$(normalize_path "$1")
        APP_FILE=$(mktemp /tmp/p4app.tar.gz.XXXXXX)
        tar -czf "$APP_FILE" -C "$PACKAGE_DIR" . &&
        rm -rf "$PACKAGE_DIR"
        mv "$APP_FILE" "$PACKAGE_DIR"
    elif [ -f "$1" ]; then
        echo "Package is already packed: $1"
    else
        echo "Couldn't read p4app package: $1"
        exit 1
    fi
}

# Unpack command function to decompress a .p4app package
function unpack-command {
    if [ -d "$1" ]; then
        echo "Package is already unpacked: $1"
    elif [ -f "$1" ]; then
        APP_FILE=$(mktemp /tmp/p4app.tar.gz.XXXXXX)
        mv "$1" "$APP_FILE" &&
        mkdir -p "$1" &&
        tar -xzf "$APP_FILE" -C "$1" &&
        rm "$APP_FILE"
    else
        echo "Couldn't read p4app package: $1"
        exit 1
    fi
}

# Docker image update function
function update-command {
    docker pull $P4APP_IMAGE
}

# Execute a command in a running container
function exec-command {
    container_id=${P4APP_NAME:-$(docker ps | grep -m1 p4app_ | awk '{print $1}')}

    if [ -z "$container_id" ]; then
        (>&2 echo "Couldn't find any p4app currently running.")
        exit 1
    fi

    if [ -t 1 ]; then
        docker exec -it $container_id "${@:1}"
    else
        docker exec $container_id "${@:1}"
    fi
}

# Print usage
function usage-command {
    echo "Usage:"
    echo "  p4app run <program.p4app>"
    echo "      Run a p4app."
    echo "  p4app run <program.p4app> <target>"
    echo "      Run a p4app, specifying a target."
    echo "  p4app build <program.p4app> <out.json>"
    echo "      Build a p4app, specifying the output JSON filename."
    echo "  p4app pack <program.p4app>"
    echo "      Compress a p4app directory into a single file, in-place."
    echo "  p4app unpack <program.p4app>"
    echo "      Expand a p4app file into a directory, in-place."
    echo "  p4app update"
    echo "      Update the toolchain to the newest version."
    echo "  p4app exec <command>"
    echo "      Execute a command on the most recent p4app instance."
    exit 1
}

# Main case selector
case "$1" in
  "run")
    run-command "${@:2}"
    ;;
  "build")
    build-command "${@:2}"
    ;;
  "pack")
    pack-command "${@:2}"
    ;;
  "unpack")
    unpack-command "${@:2}"
    ;;
  "update")
    update-command "${@:2}"
    ;;
  "exec")
    exec-command "${@:2}"
    ;;
  *)
    usage-command
    ;;
esac